/**
 * marked - a markdown parser
 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

function getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    hooks: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}

let defaults = getDefaults();

function changeDefaults(newDefaults) {
  defaults = newDefaults;
}

const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, 'g');
const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
const escapeReplacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }

  return html;
}

const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === 'string' ? regex : regex.source;
  opt = opt || '';
  const obj = {
    regex: regex,
    opt: opt,
    source: regex,
    exec: (str) => {
      const orig = obj.regex.exec(str);
      if (!orig) {
        return orig;
      }
      orig.captures = [];
      for (let i = 1; i < orig.length; i++) {
        orig.captures.push(orig[i]);
      }
      return orig;
    }
  };
  return obj;
}

function resolveHref(base, href) {
  if (!base) {
    return href;
  }

  try {
    const baseUrls = {};
    baseUrls[base] = new URL(base);

    const url = new URL(href, baseUrls[base]);
    url.protocol = url.protocol.replace(/:/g, '');
    return url.href;
  } catch (err) {
    return '';
  }
}

const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(href) {
  try {
    const prot = decodeURIComponent(unescape(href))
      .replace(nonWordAndColonTest, '')
      .toLowerCase();
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return '';
    }
  } catch (e) {
    return '';
  }
  if (!originIndependentUrl.test(href)) {
    try {
      const u = new URL(href, 'http://a.com');
      if (u.protocol !== 'http:' && u.protocol !== 'https:') {
        return '';
      }
    } catch (e) {
      return '';
    }
  }
  return href;
}

const noop = () => {};
noop.exec = noop;

function splitCells(tableRow, count) {
  const cells = tableRow.slice(1, -1).split('|');
  let i = 0;
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) {
      cells.push('');
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim();
  }
  return cells;
}

// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
// /c*$/ is vulnerable to REDOS.
// invert: Remove suffix of non-'c' characters instead. Default falsey.
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return '';
  }

  // Length of suffix matching the description.
  let suffLen = 0;

  // Step left until a character doesn't match.
  while (suffLen < l) {
    const ch = str.charAt(l - suffLen - 1);
    if (ch === c && !invert) {
      suffLen++;
    } else if (ch !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }

  return str.slice(0, l - suffLen);
}

function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}

function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
  }
}

// copied from https://github.com/jonschlinkert/remarkable/blob/master/lib/rules.js
function replace(regex, options) {
  regex = regex.source || regex;
  options = options || '';
  if (options.includes('g')) {
    caret.lastIndex = 0;
  }
  return function(name, val) {
    if (!name) return null;
    val = val.source || val;
    val = val.replace(caret, '$1');
    const newReg = new RegExp(val.replace(/\\g/g, regex), options);
    newReg.source = newReg.source.replace(/\\a/g, '\\' + 'g'); // weird!
    this[name] = newReg;
    return this[name];
  };
}

function anpa(rule) {
  return new RegExp(rule.source, rule.flags.replace('g', ''));
}

function a(flags) { return (regex) => (regex.flags ?? '').includes(flags); }
const is_g = a('g');

let block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^( {0,3})(~{3,}|`{3,})([^\n]*?)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]{3,})? *(?:\n|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^( {0,3})(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ {0,3}(?:<(script|pre|style|textarea)[^>]*?>[\s\S]*?<\/\1>|<!--[\s\S]*?-->|MathML(?:\s.*?)?>[\s\S]*?<\/MathML>|<([a-z][a-z0-9]*)(?: [^>]*?)? ?\/>|<([a-z][a-z0-9]*)(?: [^>]*?)?>[\s\S]*?<\/\2>)(?:\n{2,}|\s*$)/i,
  def: /^ {0,3}\[(.+?)\]: *([^\s]+)(?: +(["(])(.*?)\3)? *(?:\n+|$)/,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  gfm_table: /^ *\|(.+)\n {0,3}\|?( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/,
  nptable: /^ *(\S.*\|.*)\n {0,3}([-:]+ *\|[-| :]*)\n((?:(?: *[^|].*\|.*)|(?: *\|.*))(?:\n|$))*\n*/,
  paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|gfm_table|nptable|def)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"|[^"]|"[^"\n]*")*"|'(?:\\'|[^']|'[^'\n]*')*'|\((?:\\\)|[^)]|\([^)\n]*\))*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .get();

block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *\1bull ?)[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .get();
block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', `\\n+(?=${block.def.source})`)
  .get();

block._tag = `(?!(?:`
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + `|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b`;
block.html = edit(block.html, 'i')
  .replace('tag', block._tag)
  .get();

block.paragraph = edit(block.paragraph)
  .replace('hr', block.hr)
  .replace('heading', ' {0,3}#{1,6} ')
  .replace('lheading', block.lheading)
  .replace('blockquote', ' {0,3}>')
  .replace('fences', ' {0,3}(?:~{3,}|`{3,})')
  // .replace('gfm_table', block.gfm_table)
  // .replace('nptable', block.nptable)
  .replace('list', ' {0,3}(?:[*+-]|\\d{1,9}[.)]) ')
  .replace('html', ' {0,3}<')
  .replace('def', ` {0,3}\\[.+?\\]:`)
  .get();

/**
 * Normal Block Grammar
 */

block.normal = { ...block };

/**
 * GFM Block Grammar
 */

block.gfm = {
  ...block.normal,
  gfm_table: block.gfm_table,
  nptable: block.nptable
};

/**
 * Pedantic grammar
 */

block.pedantic = {
  ...block.normal,
  heading: /^(#{1,6})(?=\s)(.*)(?:\n+|$)/,
  def: /^\[(.+)\]: *<?([^\s>]+)>?(?: +(["(])(.*?)\3)? *(?:\n+|$)/,
  fences: /^(`{3,}|~{3,}) *(?:\S+)?\n(?:|([\s\S]*?)\n)(?: *\1[~`]? *)? *(?:\n+|$)/
};

/**
 * Block Lexer
 */
class Lexer {
  constructor(options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };

    const rules = {
      block: block.normal,
      inline: inline.normal
    };

    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.options.tokenizer.rules = rules;
  }

  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }

  /**
   * Static Lex Method
   */
  static lex(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  }

  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) {
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }

  /**
   * Preprocessing
   */
  lex(src) {
    src = src
      .replace(/\r\n|\r/g, '\n')
      .replace(/\t/g, '    ');

    this.blockTokens(src, this.tokens, true);

    for (let i = 0; i < this.inlineQueue.length; i++) {
      const next = this.inlineQueue[i];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];

    return this.tokens;
  }

  /**
   * Lexing
   */
  blockTokens(src, tokens = [], top = true) {
    if (this.options.hooks && this.options.hooks.preprocess) {
      src = this.options.hooks.preprocess(src);
    }

    this.state.top = top;
    const rules = this.options.tokenizer.rules.block;

    while (src) {
      // Pedantic
      if (this.options.pedantic && this.tokenizer.pedantic(src, tokens)) continue;
      // newline
      if (this.tokenizer.space(src, tokens)) continue;
      // code
      if (this.tokenizer.code(src, tokens)) continue;
      // fences
      if (this.tokenizer.fences(src, tokens)) continue;
      // heading
      if (this.tokenizer.heading(src, tokens)) continue;
      // gfm table
      if (this.tokenizer.gfm_table(src, tokens)) continue;
      // nptable
      if (this.tokenizer.nptable(src, tokens)) continue;
      // hr
      if (this.tokenizer.hr(src, tokens)) continue;
      // blockquote
      if (this.tokenizer.blockquote(src, tokens)) continue;
      // list
      if (this.tokenizer.list(src, tokens)) continue;
      // html
      if (this.tokenizer.html(src, tokens)) continue;
      // def
      if (this.tokenizer.def(src, tokens)) continue;
      // lheading
      if (this.tokenizer.lheading(src, tokens)) continue;
      // top-level paragraph
      if (this.tokenizer.paragraph(src, tokens)) continue;
      // text
      if (this.tokenizer.text(src, tokens)) {
        continue;
      }

      if (src) {
        const err = new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        err.raw = src;
        throw err;
      }
    }

    this.state.top = true;

    if (this.options.hooks && this.options.hooks.postprocess) {
      this.options.hooks.postprocess(this.tokens);
    }

    return this.tokens;
  }

  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }

  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let inLink = this.state.inLink;
    let inRawBlock = this.state.inRawBlock;
    this.state.inLink = false;
    this.state.inRawBlock = false;

    if (this.options.hooks && this.options.hooks.preparse) {
      src = this.options.hooks.preparse(src);
    }

    while (src) {
      // escape
      if (this.tokenizer.escape(src, tokens)) continue;
      // GFM autolink
      if (this.tokenizer.autolink(src, tokens)) continue;
      // url (gfm)
      if (this.tokenizer.url(src, tokens)) continue;
      // Strong/emphasis
      if (this.tokenizer.strong(src, tokens)) continue;
      // code
      if (this.tokenizer.codespan(src, tokens)) continue;
      // br
      if (this.tokenizer.br(src, tokens)) continue;
      // del (gfm)
      if (this.tokenizer.del(src, tokens)) continue;
      // tag
      if (this.tokenizer.html(src, tokens)) continue;
      // link
      if (this.tokenizer.link(src, tokens)) continue;
      // reflink, nolink
      if (this.tokenizer.reflink(src, tokens)) continue;

      // text
      if (this.tokenizer.text(src, tokens)) continue;

      if (src) {
        const err = new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        err.raw = src;
        this.state.inLink = inLink;
        this.state.inRawBlock = inRawBlock;
        throw err;
      }
    }

    if (this.options.hooks && this.options.hooks.postparse) {
      this.options.hooks.postparse(tokens);
    }

    this.state.inLink = inLink;
    this.state.inRawBlock = inRawBlock;
    return tokens;
  }
}

let inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  html: `^</?(?![a-z][a-z0-9]* ?/?>|!--|textarea>|script>|style>|pre>|iframe>|br>|hr>|MathML>)([a-z][a-z0-9]*)(?: [^>]*?)? ?/?>|(?=.)<!--(?!.)[\s\S]*?-->`,
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
  nolink: /^!?\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
  reflinkSearch: 'reflink|nolink(?!\\()',
  strong: {
    start: /^(?:(\b_|_)|(\*\*|__))(?![\s\S])/, // unused
    middle: /^(?:(?:(\b_|_)|(\*\*|__))((?:.|\n(?!$))+?)(?:\1|\2))/,
    end: /^(?:(?:(\b_|_)|(\*\*|__))((?:.|\n(?!$))+?)(?:\1|\2))(?!\1|\2)/ // unused
  },
  em: {
    start: /^(?:(\b\*|\*)|(_))(?![\s\S])/, // unused
    middle: /^(?:(?:(\b\*|\*)|(_))((?:.|\n(?!$))+?)(?:\1|\2))/,
    end: /^(?:(?:(\b\*|\*)|(_))((?:.|\n(?!$))+?)(?:\1|\2))(?!\1|\2)/ // unused
  },
  codespan: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noop,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/,
  punctuation: /^([\s*~_`])/,
};

inline._punctuation = '!"#$%&\'()*+,-.\\/:;<=>?@\\[\\]`^{|}~';
inline.punctuation = edit(inline.punctuation)
  .replace('punctuation', inline._punctuation)
  .get();

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .get();

inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\s<>\\])*>|[^\s<>\\]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .get();

inline.reflink = edit(inline.reflink)
  .replace('label', inline._label)
  .get();

/**
 * Normal Inline Grammar
 */

inline.normal = { ...inline };

/**
 * Pedantic Inline Grammar
 */
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__?(?![\s\S])/,
    middle: /^__(?:(?!__)|(?:.|\n(?!$)))+?__/,
    end: /^__(?:(?!__)|(?:.|\n(?!$)))+?__(?!_)/
  },
  em: {
    start: /^_?(?![\s\S])/,
    middle: /^_(?:(?!_)|(?:.|\n(?!$)))+?_/,
    end: /^_(?:(?!_)|(?:.|\n(?!$)))+?_(?!_)/
  },
  link: edit(/^!?\[(label)\]\((href)(?: (title))?\)/)
    .replace('label', /([^\s\]]+)/)
    .replace('href', /(?:\s+)?<((?:\\.|[^<>\s\\])+)>/)
    .replace('title', /(['"])(.*?)\1/)
    .get(),
  reflink: edit(/^!?\[(label)\]\s*\[(ref)\]/)
    .replace('label', /([^\s\]]+)/)
    .replace('ref', block._label)
    .get()
};

/**
 * GFM Inline Grammar
 */

inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace('])', '~|])').get(),
  url: edit(/^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/)
    .replace('scheme', inline._scheme)
    .get(),
  del: /^~+(?=\S)([\s\S]*?\S)~+/,
  text: edit(inline.text)
    .replace(']|', '~]|')
    .replace('|', '|https?://|')
    .get()
};

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace('{2,}', '*').get(),
  text: edit(inline.gfm.text).replace('{2,}', '*').get()
};

class Rules extends Array {
  // Use a class so we can extend it with a map
}

class InlineLexer extends Lexer {
  constructor(links, options) {
    super(options);
    this.links = links;
    this.rules = new Rules(...this.options.tokenizer.rules.inline);
    if (!this.links) {
      this.links = Object.create(null);
    }
  }

  /**
   * Static Lexing
   */
  static output(src, links, options) {
    const inline = new InlineLexer(links, options);
    return inline.output(src);
  }

  /**
   * Lexing/Compiling
   */
  output(src) {
    let out = '';

    while (src) {
      let cap;
      // escape
      if ((cap = this.tokenizer.escape(src))) {
        src = src.substring(cap.raw.length);
        out += cap.text;
        continue;
      }

      // tag
      if ((cap = this.tokenizer.html(src))) {
        src = src.substring(cap.raw.length);
        out += this.options.renderer.html(cap.raw);
        continue;
      }

      // link
      if ((cap = this.tokenizer.link(src))) {
        src = src.substring(cap.raw.length);
        out += this.outputLink(cap, {
          header: false,
          text: cap.text
        });
        continue;
      }

      // reflink, nolink
      if ((cap = this.tokenizer.reflink(src))
        || (cap = this.tokenizer.nolink(src))) {
        src = src.substring(cap.raw.length);
        cap.type = 'reflink';

        const link = this.links[cap.text.toLowerCase()];

        out += this.outputLink(cap, {
          header: false,
          href: link?.href,
          title: link?.title,
          text: cap.text
        });
        continue;
      }

      // strong
      if ((cap = this.tokenizer.strong(src))) {
        src = src.substring(cap.raw.length);
        out += this.options.renderer.strong(this.output(cap.text));
        continue;
      }

      // em
      if ((cap = this.tokenizer.em(src))) {
        src = src.substring(cap.raw.length);
        out += this.options.renderer.em(this.output(cap.text));
        continue;
      }
      // code
      if ((cap = this.tokenizer.codespan(src))) {
        src = src.substring(cap.raw.length);
        out += this.options.renderer.codespan(escape(cap.text, true));
        continue;
      }

      // br
      if ((cap = this.tokenizer.br(src))) {
        src = src.substring(cap.raw.length);
        out += this.options.renderer.br();
        continue;
      }

      // del (gfm)
      if ((cap = this.tokenizer.del(src))) {
        src = src.substring(cap.raw.length);
        out += this.options.renderer.del(this.output(cap.text));
        continue;
      }

      // autolink
      if ((cap = this.tokenizer.autolink(src))) {
        src = src.substring(cap.raw.length);
        let text, href;
        if (cap.text === 'email') {
          text = escape(this.options.mangle ? mangle(cap.val) : cap.val);
          href = 'mailto:' + text;
        } else {
          text = escape(cap.val);
          href = text;
        }
        out += this.options.renderer.link(href, null, text);
        continue;
      }

      // url (gfm)
      if (!this.state.inLink && (cap = this.tokenizer.url(src))) {
        src = src.substring(cap.raw.length);
        const text = escape(cap.text);
        const href = text;
        out += this.options.renderer.link(href, null, text);
        continue;
      }

      // text
      if ((cap = this.tokenizer.text(src))) {
        src = src.substring(cap.raw.length);
        out += this.options.renderer.text(escape(this.smartypants(cap.text)));
        continue;
      }

      if (src) {
        const err = new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        err.raw = src;
        throw err;
      }
    }

    return out;
  }

  outputLink(cap, link) {
    link.href = link.href || cap.href;
    link.title = link.title || cap.title;
    const href = this.options.renderer.options.baseUrl
      ? resolveHref(this.options.renderer.options.baseUrl, cleanUrl(link.href))
      : cleanUrl(link.href);

    const title = link.title ? escape(link.title) : null;
    const text = link.text ? this.output(link.text) : null;

    if (cap.type === 'nolink' && !href && !title && !text) {
      return this.options.renderer.text(escape(cap.raw));
    } else if (href === null) {
      return this.options.renderer.text(escape(cap.raw));
    }

    let out = '';
    if (cap.raw.charAt(0) === '!') {
      out = this.options.renderer.image(href, title, escape(link.text || ''));
    } else {
      out = this.options.renderer.link(href, title, text || '');
    }
    return out;
  }

  smartypants(text) {
    if (!this.options.smartypants) return text;
    return text
      // em-dashes
      .replace(/---/g, '\u2014')
      // en-dashes
      .replace(/--/g, '\u2013')
      // opening singles
      .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
      // closing singles & apostrophes
      .replace(/'/g, '\u2019')
      // opening doubles
      .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
      // closing doubles
      .replace(/"/g, '\u201d')
      // ellipses
      .replace(/\.{3}/g, '\u2026');
  }

  mangle(text) {
    if (!this.options.mangle) return text;
    const l = text.length;
    let out = '',
      i = 0,
      ch;

    for (; i < l; i++) {
      ch = text.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }
      out += '&#' + ch + ';';
    }

    return out;
  }
}

/**
 * Parsing & Compiling
 */
class Parser {
  constructor(options) {
    this.options = options || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }

  /**
   * Static Parse Method
   */
  static parse(tokens, options) {
    const parser = new Parser(options);
    return parser.parse(tokens);
  }

  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) {
    const parser = new Parser(options);
    return parser.parseInline(tokens);
  }

  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = '',
      i,
      j,
      k,
      l,
      m,
      token,
      nextToken,
      lastToken,
      cut,
      after,
      last,
      lastbutone;

    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !['space', 'hr', 'heading', 'gfm_table', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
          out += ret || '';
          continue;
        }
      }

      switch (token.type) {
        case 'space': {
          continue;
        }
        case 'hr': {
          out += this.renderer.hr();
          continue;
        }
        case 'heading': {
          const headingText = this.parseInline(token.tokens);
          out += this.renderer.heading(
            headingText,
            token.depth,
            unescape(headingText),
            this.slugger);
          continue;
        }
        case 'gfm_table': {
          let header = '',
            body = '',
            row,
            cell,
            j;

          // header
          cell = '';
          for (j = 0; j < token.header.length; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j]),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);

          for (j = 0; j < token.rows.length; j++) {
            row = token.rows[j];

            cell = '';
            for (let k = 0; k < row.length; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k]),
                { header: false, align: token.align[k] }
              );
            }

            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case 'code': {
          out += this.renderer.code(token.text,
            token.lang,
            token.escaped);
          continue;
        }
        case 'table': {
          let header = '',
            body = '',
            row,
            cell;

          // header
          cell = '';
          for (j = 0; j < token.header.length; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);

          for (j = 0; j < token.rows.length; j++) {
            row = token.rows[j];

            cell = '';
            for (k = 0; k < row.length; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                { header: false, align: token.align[k] }
              );
            }

            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case 'blockquote': {
          const text = this.parse(token.tokens);
          out += this.renderer.blockquote(text);
          continue;
        }
        case 'list': {
          let body = '',
            ordered = token.ordered,
            start = token.start,
            loose = token.loose;

          const l = token.items.length;
          for (j = 0; j < l; j++) {
            m = token.items[j];
            const item = m.tokens;

            // TODO: fix this, need to join list items with a newline
            // to avoid joining list items that start with a new paragraph
            // and joining the raw text of the single item with the previous
            let lastItem = tokens[j + 1] ? tokens[j + 1].raw : '';
            let isLastItem = j === l - 1 && m.raw === item[0].raw && lastItem.indexOf('\n\n') === -1;
            body += this.renderer.listitem(
              this.parse(item, loose),
              m.task,
              m.checked,
              isLastItem);
          }

          out += this.renderer.list({ body, ordered, start });
          continue;
        }
        case 'html': {
          out += this.renderer.html(token.text, token.block);
          continue;
        }
        case 'paragraph': {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case 'text': {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        default: {
          const err = new Error('Token with "' + token.type + '" type was not found.');
          err.raw = token;
          throw err;
        }
      }
    }

    return out;
  }

  /**
   * Parse Inline Tokens
   */
  parseInline(tokens) {
    let out = '',
      i,
      token;

    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];

      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !['escape', 'html', 'link', 'reflink', 'nolink', 'strong', 'em', 'codespan', 'br', 'del', 'autolink', 'url', 'text'].includes(token.type)) {
          out += ret || '';
          continue;
        }
      }

      switch (token.type) {
        case 'escape': {
          out += this.renderer.text(token.text);
          break;
        }
        case 'html': {
          out += this.renderer.html(token.text);
          break;
        }
        case 'link': {
          out += this.renderer.link(token.href, token.title, this.parseInline(token.tokens));
          break;
        }
        case 'reflink':
        case 'nolink': {
          const link = this.options.links[token.text.toLowerCase()];

          if (link && link.href) {
            out += this.renderer.link(link.href, link.title, this.parseInline(token.tokens));
          } else {
            out += token.raw;
          }
          break;
        }
        case 'strong': {
          out += this.renderer.strong(this.parseInline(token.tokens));
          break;
        }
        case 'em': {
          out += this.renderer.em(this.parseInline(token.tokens));
          break;
        }
        case 'codespan': {
          out += this.renderer.codespan(token.text);
          break;
        }
        case 'br': {
          out += this.renderer.br();
          break;
        }
        case 'del': {
          out += this.renderer.del(this.parseInline(token.tokens));
          break;
        }
        case 'autolink': {
          out += this.renderer.link(token.href, null, token.text);
          break;
        }
        case 'url': {
          out += this.renderer.link(token.href, null, token.text);
          break;
        }
        case 'text': {
          out += this.renderer.text(token.text);
          break;
        }
        default: {
          const err = new Error('Token with "' + token.type + '" type was not found.');
          err.raw = token;
          throw err;
        }
      }
    }
    return out;
  }
}

/**
 * Renderer
 */
class Renderer {
  constructor(options) {
    this.options = options || defaults;
  }

  code(code, infostring, escaped) {
    const lang = (infostring || '').match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }

    code = code.replace(/\n$/, '') + '\n';

    if (!lang) {
      return '<pre><code>'
        + (escaped ? code : escape(code, true))
        + '</code></pre>\n';
    }

    return '<pre><code class="'
      + this.options.langPrefix
      + escape(lang)
      + '">'
      + (escaped ? code : escape(code, true))
      + '</code></pre>\n';
  }

  blockquote(quote) {
    return `<blockquote>\n${quote}</blockquote>\n`;
  }

  html(html, block) {
    return html;
  }

  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text}</h${level}>\n`;
    }
    // ignore IDs
    return `<h${level}>${text}</h${level}>\n`;
  }

  hr() {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  }

  list({ body, ordered, start }) {
    const type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
  }

  listitem(text, task, checked) {
    let item = '<li>';
    if (task) {
      item += '<input '
        + (checked ? 'checked="" ' : '')
        + 'disabled="" type="checkbox">';
    }
    item += text + '</li>\n';
    return item;
  }

  checkbox(checked) {
    return '<input '
      + (checked ? 'checked="" ' : '')
      + 'disabled="" type="checkbox">';
  }

  paragraph(text) {
    return '<p>' + text + '</p>\n';
  }

  table(header, body) {
    if (body) body = '<tbody>' + body + '</tbody>';

    return '<table>\n'
      + '<thead>\n'
      + header
      + '</thead>\n'
      + body
      + '</table>\n';
  }

  tablerow(content) {
    return '<tr>\n' + content + '</tr>\n';
  }

  tablecell(content, flags) {
    const type = flags.header ? 'th' : 'td';
    const tag = flags.align
      ? '<' + type + ' align="' + flags.align + '">'
      : '<' + type + '>';
    return tag + content + '</' + type + '>\n';
  }

  /**
   * span level renderer
   */
  strong(text) {
    return '<strong>' + text + '</strong>';
  }

  em(text) {
    return '<em>' + text + '</em>';
  }

  codespan(text) {
    return '<code>' + text + '</code>';
  }

  br() {
    return this.options.xhtml ? '<br/>' : '<br>';
  }

  del(text) {
    return '<del>' + text + '</del>';
  }

  link(href, title, text) {
    const cleanHref = cleanUrl(this.options.sanitize ? '' : href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + escape(href) + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += '>' + text + '</a>';
    return out;
  }

  image(href, title, text) {
    const cleanHref = cleanUrl(this.options.sanitize ? '' : href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;

    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? '/>' : '>';
    return out;
  }

  text(text) {
    return text;
  }
}

/**
 * TextRenderer
 * returns only the textual part of the token
 */
class TextRenderer {
  // no need for block level renderers
  strong(text) {
    return text;
  }

  em(text) {
    return text;
  }

  codespan(text) {
    return text;
  }

  del(text) {
    return text;
  }

  html(html) {
    return html;
  }

  text(text) {
    return text;
  }

  link(href, title, text) {
    return '' + text;
  }

  image(href, title, text) {
    return '' + text;
  }

  br() {
    return '';
  }
}

/**
 * Slugger generates header id's
 */
class Slugger {
  constructor() {
    this.seen = {};
  }

  /**
   * Squeeze consecutive dashes into one
   */
  // slug(value) {
  //   let slug = value
  //     .toLowerCase()
  //     .trim()
  //     .replace(/<[!\/a-z].*?>/ig, '') // remove html tags
  //     .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '') // remove punctuation
  //     .replace(/\s/g, '-'); // replace spaces with dashes

  //   if (this.seen[slug]) {
  //     const originalSlug = slug;
  //     do {
  //       this.seen[originalSlug]++;
  //       slug = originalSlug + '-' + this.seen[originalSlug];
  //     } while (this.seen[slug]);
  //   }
  //   this.seen[slug] = 0;

  //   return slug;
  // }
  slug(value, options) {
    const slug = value
      .toLowerCase()
      .trim()
      .replace(/<[!\/a-z].*?>/ig, '') // remove html tags
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '') // remove punctuation
      .replace(/\s/g, '-');

    if (this.seen.hasOwnProperty(slug)) {
      const originalSlug = slug;
      do {
        this.seen[originalSlug]++;
        slug = originalSlug + '-' + this.seen[originalSlug];
      } while (this.seen.hasOwnProperty(slug));
    }
    this.seen[slug] = 0;

    return slug;
  }
}

/**
 * Tokenizer
 */
class Tokenizer {
  constructor(options) {
    this.options = options || defaults;
  }

  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: 'space',
        raw: cap[0]
      };
    }
  }

  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {4}/gm, '');
      return {
        type: 'code',
        raw: cap[0],
        codeBlockStyle: 'indented',
        text: !this.options.pedantic
          ? rtrim(text, '\n')
          : text
      };
    }
  }

  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = cap[3] || '';
      return {
        type: 'code',
        raw,
        lang: cap[2] ? cap[2].trim().replace(/ .*/, '') : cap[2],
        text
      };
    }
  }

  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[3].trim();

      // remove trailing #s
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, '#');
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          // CommonMark requires space before trailing #s
          text = trimmed.trim();
        }
      }

      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[2].length,
        text: text,
        tokens: this.lexer.inline(text)
      };
    }
  }

  nptable(src) {
    if (!this.options.gfm) {
      return;
    }
    const cap = this.rules.block.nptable.exec(src);
    if (cap) {
      const item = {
        type: 'gfm_table',
        raw: cap[0],
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        rows: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (!item.header.length || item.header.length !== item.align.length) {
        return;
      }

      for (let i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (let i = 0; i < item.rows.length; i++) {
        item.rows[i] = splitCells(item.rows[i], item.header.length);
      }

      return item;
    }
  }

  gfm_table(src) {
    if (!this.options.gfm) {
      return;
    }
    const cap = this.rules.block.gfm_table.exec(src);
    if (cap) {
      const item = {
        type: 'gfm_table',
        raw: cap[0],
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        rows: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (!item.header.length || item.header.length !== item.align.length) {
        return;
      }

      for (let i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (let i = 0; i < item.rows.length; i++) {
        item.rows[i] = splitCells(item.rows[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
      }

      return item;
    }
  }

  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }

  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: 'hr',
        raw: cap[0]
      };
    }
  }

  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *> ?/gm, '');
      const top = this.lexer.state.top;
      this.lexer.state.top = false;
      const tokens = this.lexer.blockTokens(text, []);
      this.lexer.state.top = top;
      return {
        type: 'blockquote',
        raw: cap[0],
        tokens,
        text
      };
    }
  }

  list(src) {
    const cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[2].trim();
      const isordered = bull.length > 1;

      const list = {
        type: 'list',
        raw: '',
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : '',
        loose: false,
        items: []
      };

      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;

      if (this.options.pedantic) {
        bull = isordered ? bull : '[*+-]';
      }

      // Get each top-level item.
      const itemMatch = new RegExp(`^( {0,3}${bull})((?:[\t ]*))([\\s\\S]+?)(?=\\n{2,}(?! )(?![\\t ]*${bull})\\n*|\\s*$)`);
      let next = false,
        item,
        space,
        raw,
        b,
        addBack,
        loose,
        istask,
        ischecked,
        text;

      let source = cap[0];
      // Check if we have an item which starts with letters
      if (!isordered && /^[a-zA-Z]/.test(cap[3])) {
        // Not a list, if letters are not followed by a dot.
        const dot = cap[3].indexOf('.');
        if (dot === -1 || dot > 5) {
          return;
        }
      }

      while (source) {
        item = itemMatch.exec(source);

        if (!item) {
          // No more list items
          break;
        }

        raw = item.input.substring(0, item[0].length);
        text = item[3];

        b = item[2].length;
        space = item[2].replace(/\t/g, '    ');
        let itemContents = '';

        if (text) {
          if (/\n{2,}$/.test(text)) {
            loose = true;
          }

          if (this.options.pedantic) {
            // Pedantic: Remove the spacing from the beginning of the item
            itemContents = space + text;
          } else {
            // Get the item content, preserving indentation
            const N = text.length;
            let i = 0, ch, nlen;
            while (i < N && (ch = text.charCodeAt(i))) {
              if (ch === 10) { // \n
                let s = 1,
                  sp,
                  nc;
                // screen for newline, up to `b` spaces
                while (s <= b && i + s < N && (sp = text.charCodeAt(i + s)) &&
                  (sp === 32 || sp === 9)) { // ' ' or '\t'
                  s++;
                }
                if (s > b) {
                  nlen = s - b;
                  while (nlen) {
                    itemContents += ' ';
                    nlen--;
                  }
                  i += s - 1;
                } else {
                  itemContents += text[i];
                }
              } else {
                itemContents += text[i];
              }
              i++;
            }
          }
        }

        next = false;
        if (loose) {
          list.loose = true;
        }

        // Check for task list items
        istask = /^\[[ xX]\] /.test(itemContents);
        ischecked = undefined;
        if (istask) {
          ischecked = itemContents[1] !== ' ';
          itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
        }

        list.items.push({
          type: 'list_item',
          raw,
          task: istask,
          checked: ischecked,
          loose: loose,
          text: itemContents,
          tokens: []
        });

        list.raw += raw;
        source = source.substring(item[0].length);
      }

      // list item tokens
      const l = list.items.length;
      for (let i = 0; i < l; i++) {
        this.lexer.blockTokens(list.items[i].text, list.items[i].tokens, false);
      }

      return list;
    }
  }

  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: 'html',
        block: true,
        raw: cap[0],
        pre: cap[1] && ['pre', 'script', 'style', 'textarea'].includes(cap[1].toLowerCase()),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text = this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0]);
        token.type = 'paragraph';
        token.text = text;
        token.tokens = this.lexer.inline(text);
      }
      return token;
    }
  }

  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      if (!this.lexer.tokens.links[tag]) {
        this.lexer.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      return {
        type: 'def',
        tag,
        raw: cap[0],
        href: cap[2],
        title: cap[3]
      };
    }
  }

  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === '\n'
        ? cap[1].slice(0, -1)
        : cap[1];
      return {
        type: 'paragraph',
        raw: cap[0],
        text: text,
        tokens: this.lexer.inline(text)
      };
    }
  }

  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: 'text',
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }

  // ---- Inline Rules ----
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: 'escape',
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }

  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === '@') {
        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }

      return {
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: 'text',
            raw: text,
            text
          }
        ]
      };
    }
  }

  url(src) {
    if (!this.options.gfm) {
      return;
    }
    const cap = this.rules.inline.url.exec(src);
    if (cap) {
      const text = escape(cap[1]);
      const href = text;
      return {
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: 'text',
            raw: text,
            text
          }
        ]
      };
    }
  }

  html(src) {
    if (!this.options.tokenizer) {
      const cap = this.rules.inline.html.exec(src);
      if (cap) {
        return {
          type: 'html',
          raw: cap[0],
          text: escape(cap[1])
        };
      }
    }
    const cap = this.rules.inline.html.exec(src);
    if (cap) {
      const token = {
        type: 'html',
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        block: false
      };
      if (this.options.sanitize) {
        const text = this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0]);
        token.type = 'text';
        token.text = text;
      } else if (this.lexer.state.inRawBlock) {
        token.type = 'text';
        token.text = cap[0];
      } else {
        token.text = cap[0];
      }
      return token;
    }
  }

  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = cap[1];
      const href = cap[2].trim();
      const title = cap[3] ? cap[3].slice(1, -1) : '';
      const token = {
        type: 'link',
        raw,
        href,
        title,
        text,
        tokens: this.lexer.inline(text)
      };
      return token;
    }
  }

  reflink(src) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src))
        || (cap = this.rules.inline.nolink.exec(src))) {
      const text = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      const link = this.lexer.tokens.links[text.toLowerCase()];
      if (!link) {
        return {
          type: 'text',
          raw: cap[0],
          text: cap[0]
        };
      }
      return {
        type: 'link',
        raw: cap[0],
        text: cap[1],
        href: link.href,
        title: link.title,
        tokens: this.lexer.inline(cap[1])
      };
    }
  }

  reflinkSearch(src, tokens) {
    if (!this.options.gfm) return;
    const search = this.rules.inline.reflinkSearch;
    let newsrc = '', lastToken, lastParen, fromIndex = 0;
    while ((lastToken = search.exec(src.substring(fromIndex)))) {
      const token = tokens[tokens.length - 1];
      if (token?.type === 'text') {
        const raw = token.raw;
        const lastLink = /!?\[((?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*)\]\s*\[((?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*)\]/g;
        while ((lastParen = lastLink.exec(raw))) {
          const text = (lastParen[2] || lastParen[1]).replace(/\s+/g, ' ');
          if (this.tokens.links[text.toLowerCase()]) {
            token.text = token.text.substring(0, lastParen.index) + lastParen[0];
            return true;
          }
        }
      }
      fromIndex = lastToken.index + lastToken[0].length;
    }
  }

  strong(src) {
    let match = this.rules.inline.strong.middle.exec(src);
    if (match) {
      return {
        type: 'strong',
        raw: match[0],
        text: match[3] || match[2] || match[1],
        tokens: this.lexer.inline(match[3] || match[2] || match[1])
      };
    }
  }

  em(src) {
    let match = this.rules.inline.em.middle.exec(src);
if (match) {
      return {
        type: 'em',
        raw: match[0],
        text: match[3] || match[2] || match[1],
        tokens: this.lexer.inline(match[3] || match[2] || match[1])
      };
    }
  }

  codespan(src) {
    const cap = this.rules.inline.codespan.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, ' ');
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: 'codespan',
        raw: cap[0],
        text
      };
    }
  }

  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: 'br',
        raw: cap[0]
      };
    }
  }

  del(src) {
    if (!this.options.gfm) {
      return;
    }
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: 'del',
        raw: cap[0],
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }

  text(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      return {
        type: 'text',
        raw: cap[0],
        text: cap[0]
      };
    }
  }

  pedantic(src) {
    return this.options.pedantic
      // Not implemented
      ? false
      : false;
  }
}

function marked(src, opt) {
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (opt && opt.hooks) {
    opt.hooks.log = (...args) => console.log(...args);
  }

  if (opt && opt.async) {
    return Promise.resolve(marked.parse(src, opt));
  }

  try {
    const options = { ...defaults, ...opt };
    checkSanitizeDeprecation(options);
    const tokens = Lexer.lex(src, options);

    if (options.hooks) {
      options.hooks.postprocess(tokens);
    }
    const parser = new Parser(options);
    const html = parser.parse(tokens);
    if (options.hooks) {
      html = options.hooks.postprocess(html);
    }
    return html;
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

marked.options = marked.setOptions = function(opt) {
  marked.defaults = { ...marked.defaults, ...opt };
  changeDefaults(marked.defaults);
  return marked;
};

marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const options = { ...marked.defaults };
  for (const arg of args) {
    if (typeof arg !== 'object' || arg === null) continue;
    Object.assign(options, arg);
  }
  marked.setOptions(options);
};

marked.parse = marked;

const options = marked.options;
const setOptions = marked.setOptions;
const use = marked.use;
const getDefaults_1 = marked.getDefaults;
const fm = (src, opt) => {
  const val = marked(src, opt);
  return val;
};
fm.options = options;
fm.setOptions = setOptions;
fm.use = use;
fm.getDefaults = getDefaults_1;
const lexer = Lexer.lex;
const lexer_1 = Lexer.lexInline;
fm.lexer = lexer;
fm.lexer.inline = lexer_1;
fm.parser = Parser.parse;

export { Lexer, Parser, Renderer, Slugger, TextRenderer, Tokenizer, defaults, fm as marked, setOptions as options };
